# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qvqrd6yQw4GshN5X-UUT4ktoCMgxRdnx
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ball_hyp.yaml
# augment: true
# 
# # Color & lighting
# hsv_h: 0.015
# hsv_s: 0.3
# hsv_v: 0.4
# 
# # Geometry
# degrees: 0.0
# translate: 0.1
# scale: 0.2
# shear: 0.0
# perspective: 0.0
# flipud: 0.0
# fliplr: 0.5
# 
# # CRITICAL FOR CRICKET BALL
# motion: 0.4
# blur: 0.3
# erasing: 0.4
# 
# # Context (keep low)
# mosaic: 0.1
# mixup: 0.0
# copy_paste: 0.0
#

# # ================= FINAL BALL TRACKING (YOLO + KALMAN + OPTICAL FLOW) =================

# !pip install -q ultralytics filterpy opencv-python tqdm

# from google.colab import drive
# drive.mount('/content/drive')

# # ---------------- PATHS ----------------
# MODEL_PATH  = "/content/drive/MyDrive/yolon26.pt"
# VIDEO_PATH  = "/content/drive/MyDrive/3.mp4"
# OUTPUT_PATH = "/content/drive/MyDrive/output_final.avi"
# FRAMES_DIR  = "/content/drive/MyDrive/output_final_frames"

# BALL_CLASS_ID = 0
# CONF_THRES = 0.2
# IOU_THRES  = 0.4

# # ---------------- IMPORTS ----------------
# import cv2, os
# import numpy as np
# from ultralytics import YOLO
# from collections import deque
# from filterpy.kalman import KalmanFilter
# from tqdm import tqdm

# os.makedirs(FRAMES_DIR, exist_ok=True)

# # ---------------- LOAD MODEL ----------------
# model = YOLO(MODEL_PATH)

# # ---------------- VIDEO ----------------
# cap = cv2.VideoCapture(VIDEO_PATH)
# w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
# h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
# fps = cap.get(cv2.CAP_PROP_FPS)
# if fps == 0 or fps != fps:
#     fps = 25.0

# total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

# out = cv2.VideoWriter(
#     OUTPUT_PATH,
#     cv2.VideoWriter_fourcc(*'XVID'),
#     fps,
#     (w, h)
# )

# # ---------------- KALMAN FILTER ----------------
# kf = KalmanFilter(dim_x=4, dim_z=2)
# kf.F = np.array([[1,0,1,0],
#                  [0,1,0,1],
#                  [0,0,1,0],
#                  [0,0,0,1]])
# kf.H = np.array([[1,0,0,0],
#                  [0,1,0,0]])
# kf.P *= 1000
# kf.R *= 30      # trust prediction more
# kf.Q *= 0.003   # smoother motion

# trajectory = deque(maxlen=50)
# initialized = False
# prev_gray = None
# prev_point = None
# miss_count = 0
# MAX_MISSES = 7

# # ---------------- MAIN LOOP ----------------
# for _ in tqdm(range(total_frames)):
#     ret, frame = cap.read()
#     if not ret:
#         break

#     gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
#     detected = False

#     # -------- YOLO DETECTION --------
#     results = model(frame, conf=CONF_THRES, iou=IOU_THRES, verbose=False)
#     boxes = results[0].boxes

#     if boxes is not None:
#         for box in boxes:
#             if int(box.cls[0]) == BALL_CLASS_ID:
#                 x1,y1,x2,y2 = map(int, box.xyxy[0])
#                 cx, cy = (x1+x2)//2, (y1+y2)//2
#                 detected = True
#                 miss_count = 0

#                 if not initialized:
#                     kf.x = np.array([[cx],[cy],[0],[0]])
#                     initialized = True
#                 else:
#                     kf.update(np.array([[cx],[cy]]))

#                 prev_point = np.array([[cx, cy]], dtype=np.float32)
#                 break

#     # -------- OPTICAL FLOW FALLBACK --------
#     if not detected and initialized and prev_gray is not None and prev_point is not None:
#         miss_count += 1
#         if miss_count <= MAX_MISSES:
#             next_pt, status, _ = cv2.calcOpticalFlowPyrLK(
#                 prev_gray, gray, prev_point, None,
#                 winSize=(15,15), maxLevel=2
#             )
#             if status[0][0] == 1:
#                 cx, cy = next_pt[0]
#                 kf.update(np.array([[cx],[cy]]))
#                 prev_point = next_pt

#     # -------- KALMAN PREDICTION --------
#     if initialized:
#         kf.predict()
#         px = int(kf.x[0,0])
#         py = int(kf.x[1,0])
#         trajectory.append((px, py))
#         cv2.circle(frame, (px, py), 5, (0,255,0), -1)

#     for i in range(1, len(trajectory)):
#         cv2.line(frame, trajectory[i-1], trajectory[i], (0,0,255), 2)

#     frame_id = int(cap.get(cv2.CAP_PROP_POS_FRAMES))
#     cv2.imwrite(f"{FRAMES_DIR}/frame_{frame_id:04d}.png", frame)
#     out.write(frame)

#     prev_gray = gray.copy()

# cap.release()
# out.release()
# cv2.destroyAllWindows()

# print("DONE ")

# ===============================================================
# FINAL CRICKET BALL TRACKING (ONE BLOCK ONLY)
# Mount + Install + YOLO Detection + Tracking
# Output:
#   - MP4 with trajectory
#   - CSV: frame,x,y,visible
# ===============================================================

# ---------------- SAFE DRIVE MOUNT ----------------
import os
from google.colab import drive
import shutil # Added for rmtree

mount_point = "/content/drive"

# Check if it's already mounted
if os.path.ismount(mount_point):
    print(" Drive already mounted")
else:
    # If not mounted, check if the mount_point directory exists and is not empty
    if os.path.exists(mount_point) and os.path.isdir(mount_point):
        if len(os.listdir(mount_point)) > 0:
            print(f" Warning: Mountpoint '{mount_point}' exists and is not empty, but is not mounted.")
            print("Attempting to delete and re-create the empty directory for mounting.")
            try:
                # DANGER: This will delete any existing files/folders in /content/drive
                # if it's not a mount point. Proceed with caution.
                shutil.rmtree(mount_point)
                print(f" Successfully deleted non-empty directory: {mount_point}")
            except Exception as e:
                print(f" Error deleting existing mountpoint directory '{mount_point}': {e}")
                print("Please restart the Colab runtime or manually clear /content/drive and try again.")
                # If we cannot clear, we cannot proceed cleanly.
                raise

    # Ensure the mount point directory exists and is empty before mounting
    if not os.path.exists(mount_point):
        os.makedirs(mount_point)

    try:
        drive.mount(mount_point, force_remount=True)
        print(" Google Drive mounted successfully")
    except Exception as e:
        print(f" Error mounting Google Drive: {e}")
        print("Please ensure you have authenticated Google Drive and try again. You might need to restart the Colab runtime.")
        raise # Re-raise the exception after providing more context

# ---------------- INSTALL DEPENDENCIES ----------------
!pip install -q ultralytics opencv-python tqdm

# ---------------- IMPORTS ----------------
import csv
import cv2
import numpy as np
from collections import deque
from tqdm import tqdm
from ultralytics import YOLO

# ---------------- PATHS ----------------
VIDEO_DIR  = "/content/drive/MyDrive/videos"
OUTPUT_DIR = "/content/drive/MyDrive/outputs"
MODEL_PATH = "/content/drive/MyDrive/final.pt"

os.makedirs(OUTPUT_DIR, exist_ok=True)

# ---------------- PARAMETERS ----------------
BALL_CLASS_ID = 0
CONF_THRES = 0.25
IOU_THRES  = 0.4

MAX_MISS = 6
MAX_JUMP = 60
SNAP_RADIUS = 80
TRAJ_LEN = 100

INTERP_STEP = 6
MAX_EXTRAPOLATE = 2

# ---------------- HELPERS ----------------
def valid_jump(p1, p2, max_dist):
    return np.linalg.norm(p1 - p2) <= max_dist

def is_valid_flow_point(p):
    return p is not None and p.shape == (1, 1, 2)

def interpolate_points(p1, p2, step):
    dist = np.linalg.norm(p2 - p1)
    if dist < step:
        return []
    n = int(dist // step)
    return [
        tuple((p1 + (p2 - p1) * i / n).astype(int))
        for i in range(1, n)
    ]

# ---------------- LOAD MODEL ----------------
print(" Loading YOLO model...")
model = YOLO(MODEL_PATH)
print(" Model loaded")

# ---------------- LOAD VIDEOS ----------------
video_files = sorted([v for v in os.listdir(VIDEO_DIR) if v.endswith(".mp4")])
print(f" Found {len(video_files)} videos")

# ================= PROCESS EACH VIDEO =================
for vid in video_files:
    print(f"\n Processing {vid}")

    VIDEO_PATH = os.path.join(VIDEO_DIR, vid)
    NAME = os.path.splitext(vid)[0]

    OUT_VIDEO = os.path.join(OUTPUT_DIR, f"{NAME}_trajectory.mp4")
    OUT_CSV   = os.path.join(OUTPUT_DIR, f"{NAME}.csv")

    cap = cv2.VideoCapture(VIDEO_PATH)
    if not cap.isOpened():
        print(f" Cannot open {vid}")
        continue

    w   = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    h   = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = cap.get(cv2.CAP_PROP_FPS)
    if fps == 0 or fps != fps:
        fps = 25.0

    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    out = cv2.VideoWriter(
        OUT_VIDEO,
        cv2.VideoWriter_fourcc(*"mp4v"),
        fps,
        (w, h)
    )

    # -------- CSV SETUP --------
    csv_file = open(OUT_CSV, "w", newline="")
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(["frame", "x", "y", "visible"])

    # -------- TRACKING STATE --------
    ball_point = None
    flow_point = None
    prev_gray  = None
    trajectory = deque(maxlen=TRAJ_LEN)
    miss_count = 0
    extrap_count = 0

    # ================= FRAME LOOP =================
    for frame_idx in tqdm(range(total_frames)):
        ret, frame = cap.read()
        if not ret:
            break

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        yolo_detected = False

        # ---------- YOLO DETECTION ----------
        results = model(frame, conf=CONF_THRES, iou=IOU_THRES, verbose=False)
        boxes = results[0].boxes

        if boxes is not None:
            for box in boxes:
                if int(box.cls[0]) == BALL_CLASS_ID:
                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                    cx, cy = (x1 + x2) // 2, (y1 + y2) // 2
                    candidate = np.array([cx, cy], dtype=np.float32)

                    if ball_point is None or valid_jump(ball_point, candidate, SNAP_RADIUS):
                        ball_point = candidate
                        flow_point = np.array([[[cx, cy]]], dtype=np.float32)
                        miss_count = 0
                        extrap_count = 0
                        yolo_detected = True
                    break

        # ---------- OPTICAL FLOW ----------
        if (
            not yolo_detected and
            ball_point is not None and
            prev_gray is not None and
            is_valid_flow_point(flow_point) and
            miss_count < MAX_MISS
        ):
            next_pt, status, _ = cv2.calcOpticalFlowPyrLK(
                prev_gray, gray, flow_point, None,
                winSize=(21, 21),
                maxLevel=3,
                criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 30, 0.01)
            )

            if status is not None and status[0][0] == 1:
                candidate = next_pt.reshape(2,)
                if valid_jump(ball_point, candidate, MAX_JUMP):
                    ball_point = candidate
                    flow_point = next_pt.astype(np.float32)
                    miss_count += 1
                else:
                    ball_point = None
                    flow_point = None
            else:
                ball_point = None
                flow_point = None

        # ---------- SHORT EXTRAPOLATION ----------
        if ball_point is None and len(trajectory) >= 2 and extrap_count < MAX_EXTRAPOLATE:
            p2 = np.array(trajectory[-1])
            p1 = np.array(trajectory[-2])
            velocity = p2 - p1
            if np.linalg.norm(velocity) < MAX_JUMP:
                ball_point = (p2 + velocity).astype(np.float32)
                extrap_count += 1
        else:
            extrap_count = 0

        # ---------- DRAW + CSV ----------
        if ball_point is not None:
            px, py = map(int, ball_point)
            trajectory.append((px, py))
            cv2.circle(frame, (px, py), 5, (0, 255, 0), -1)
            csv_writer.writerow([frame_idx, float(px), float(py), 1])
        else:
            csv_writer.writerow([frame_idx, -1, -1, 0])

        for i in range(1, len(trajectory)):
            p1 = np.array(trajectory[i-1])
            p2 = np.array(trajectory[i])
            if np.linalg.norm(p2 - p1) < MAX_JUMP:
                cv2.line(frame, tuple(p1), tuple(p2), (0, 0, 255), 2)
                for pt in interpolate_points(p1, p2, INTERP_STEP):
                    cv2.circle(frame, pt, 2, (255, 0, 0), -1)

        out.write(frame)
        prev_gray = gray.copy()

    cap.release()
    out.release()
    csv_file.close()

    print(f" Video saved: {OUT_VIDEO}")
    print(f" CSV saved:   {OUT_CSV}")

print("\n ALL VIDEOS DONE â€” SUBMISSION READY")